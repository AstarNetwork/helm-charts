# -- Number of replicas
replicas: 1

ethereumChain: ""

# -- Node selector for pods
nodeSelector: {}
  # karpenter.sh/nodepool: lvm-localpv
  # node.kubernetes.io/instance-type: i3.4xlarge

persistence:
  size: ""
  storageClassName: lvm-localpv

erigon:
  image:
    repository: erigontech/erigon
    tag: v3.0.3
  resources:
    requests:
      cpu: 2
      memory: 16Gi
    limits:
      # cpu: 500m
      memory: 24Gi

ethereumExporter:
  enabled: true
  image:
    repository: ethpandaops/ethereum-metrics-exporter
    tag: 0.27.1-debian
  resources:
    limits:
      cpu: 500m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 64Mi

dataSnapshot:
  # Adds init container to restare data from S3 snapshot
  restoreData: false
  # Creates cronjob to schedule data abackups to S3
  backupData: false

  # -- Backup bucket name
  bucketName: ""
  # -- Backup bucket region
  bucketRegion: ""
  # -- Backup bucket prefix
  bucketPrefix: ""
  # IAM role to dowenload/upload data from/to S3
  awsSnapshotIamRoleArn: ""

  schedule: "0 0 * * *"
  # -- Backup retention
  retention: 7

# -- Pod annotations
podAnnotations:
  karpenter.sh/do-not-disrupt: "true"

p2pNlb:
  #* AWS EIP to attach to NLB exposing p2p ports
  eIPs: []
  #* Security group to attach to NLB exposing p2p ports
  securityGroup: ""
  #* Subnet name without az name, subnets should be named in the following way: `${publicSubnetPrefix}-${azName}`.
  subnetPrefix: ""

ethereumClients: erigon

ingress:
  # -- Ingress resource for the HTTP API
  enabled: false
  # -- Annotations for Ingress
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  # -- Ingress host
  hosts:
    - host: chart-example.local
      paths: []
  # -- Ingress TLS
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

serviceAccount:
  #* if dataSnapshot.restoreData is true, or  dataSnapshot.backupData is true
  #* awsSnapshotIamRoleArn will be added to annotations of the SA
  annotations: {}
  name: node

# -- Overrides the chart's computed fullname
fullnameOverride: node

# -- The security context for pods
# @default -- See `values.yaml`
securityContext:
  runAsGroup: 1001
  # runAsNonRoot: true   #! todo
  runAsUser: 1001
  fsGroupChangePolicy: "OnRootMismatch"

# -- The security context for containers
# @default -- See `values.yaml`
containerSecurityContext:
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  runAsNonRoot: true
  runAsUser: 1001

tolerations:
  - effect: NoSchedule
    key: lvm-localpv
    operator: Equal
    value: "true"

topologySpreadConstraints:
  - labelSelector:
      matchLabels:
        statefulsetname: node
    maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: DoNotSchedule

vmPodScrape:
  # -- If true, a ServiceMonitor CRD is created for a prometheus operator
  # https://github.com/coreos/prometheus-operator
  enabled: true
  #* region to use in region_pod label
  #* This is used to identify the region of the pod in the metrics
  region: ""
  # # -- Path to scrape
  # path: /debug/metrics/prometheus
  # # -- Alternative namespace for ServiceMonitor
  # namespace: null
  # # -- Additional ServiceMonitor labels
  # labels: {}
  # # -- Additional ServiceMonitor annotations
  # annotations: {}
  # # -- ServiceMonitor scrape interval
  # interval: 1m
  # # -- ServiceMonitor scheme
  # scheme: http
  # # -- ServiceMonitor TLS configuration
  # tlsConfig: {}
  # # -- ServiceMonitor scrape timeout
  # scrapeTimeout: 30s
  # # -- ServiceMonitor relabelings
  # relabelings: []
pullPolicy: IfNotPresent
# -- Pod management policy
podManagementPolicy: Parallel

rbac:
  create: true
  rules:
    - apiGroups: ['*']
      resources:
        - services
      verbs: ['*']
    - apiGroups: ['*']
      resources:
        - pods
      verbs: ['*']

# -- How long to wait until the pod is forcefully terminated
terminationGracePeriodSeconds: 90
# -- Affinity configuration for pods
affinity: {}

# -- Pod labels
podLabels: {}

# -- Image pull secrets for Docker images
imagePullSecrets: []

# -- Annotations for the StatefulSet
annotations: {}

# -- Overrides the chart's name
nameOverride: ""

# -- Pod priority class
priorityClassName: null

# -- Define the PodDisruptionBudget spec
# If not set then a PodDisruptionBudget will not be created
podDisruptionBudget: {}
# minAvailable: 1
# maxUnavailable: 1

# -- Update strategy for the Statefulset
updateStrategy:
  # -- Update strategy type
  type: RollingUpdate

# -- Additional volumes
extraVolumes: []

# -- Additional volume mounts
extraVolumeMounts: []

# -- Additional ports. Useful when using extraContainers or extraContainerPorts
extraPorts: []

# -- Additional ports for the main container
extraContainerPorts: []

# -- Additional env variables
extraEnv: []

# -- Additional env variables injected via a created secret
secretEnv: {}
# MY_PASSWORD: supersecret

# initChownData:
#   # -- Init container to set the correct permissions to access data directories
#   enabled: true
#   image:
#     # -- Container repository
#     repository: busybox
#     # -- Container tag
#     tag: 1.34.0
#     # -- Container pull policy
#     pullPolicy: IfNotPresent
#   # -- Resource requests and limits
#   resources: {}
#   #  limits:
#   #    cpu: 100m
#   #    memory: 128Mi
#   #  requests:
#   #    cpu: 100m
#   #    memory: 128Mi



# -- Template used for the default command
# @default -- See `values.yaml`
# defaultCommandTemplate: |
#   - sh
#   - -ac
#   - >
#   {{- if .Values.p2pNodePort.enabled }}
#     . /env/init-nodeport;
#   {{- end }}
#     exec /usr/local/bin/reth node
#     --datadir=/data
#     --config=/data/config.toml
#   {{- if .Values.p2pNodePort.enabled }}
#     {{- if not (contains "--nat=" (.Values.extraArgs | join ",")) }}
#     --nat=extip:$EXTERNAL_IP
#     {{- end }}
#     {{- if not (contains "--port=" (.Values.extraArgs | join ",")) }}
#     --port=$EXTERNAL_PORT
#     {{- end }}
#   {{- else }}
#     {{- if not (contains "--nat=" (.Values.extraArgs | join ",")) }}
#     --nat=extip:$(POD_IP)
#     {{- end }}
#     {{- if not (contains "--port=" (.Values.extraArgs | join ",")) }}
#     --port={{ include "reth.p2pPort" . }}
#     {{- end }}
#   {{- end }}
#     --http
#     --http.addr=0.0.0.0
#     --http.port={{ .Values.httpPort }}
#     --http.corsdomain=*
#     --ws
#     --ws.addr=0.0.0.0
#     --ws.port={{ .Values.wsPort }}
#     --ws.origins=*
#     --authrpc.jwtsecret=/data/jwt.hex
#     --authrpc.addr=0.0.0.0
#     --authrpc.port={{ .Values.authPort }}
#     --log.file.directory=/data/logs
#   {{- if .Values.metricsPort }}
#     --metrics=0.0.0.0:{{ .Values.metricsPort }}
#   {{- end }}
#   {{- range .Values.extraArgs }}
#     {{ tpl . $ }}
#   {{- end }}

# # -- Legacy way of overwriting the default command. You may prefer to change defaultCommandTemplate instead.
# customCommand: []

# When p2pNodePort is enabled, your P2P port will be exposed via service type NodePort.
# This is useful if you want to expose and announce your node to the Internet.
# Limitation: You can only one have one replica when exposing via NodePort.
#             Check the chart README.md for more details
# p2pNodePort:
#   # -- Expose P2P port via NodePort
#   enabled: false
#   # -- NodePort to be used
#   port: 31000
#   initContainer:
#     image:
#       # -- Container image to fetch nodeport information
#       repository: lachlanevenson/k8s-kubectl
#       # -- Container tag
#       tag: v1.25.4
#       # -- Container pull policy
#       pullPolicy: IfNotPresent
#   portForwardContainer:
#     image:
#       # -- Container image for the port forwarder
#       repository: alpine/socat
#       # -- Container tag
#       tag: latest
#       # -- Container pull policy
#       pullPolicy: IfNotPresent
